
产品名称Product name
密级Confidentiality level
和新员工一起学NP-IQM	内部公开
产品版本Product version	Total 25 pages 共25页
V1.0	

和新员工一起学NP-IQM

Prepared by
拟制	姓名 工号
陈世锐	Date
日期	2015-11-02
	
	 
	
Huawei Technologies Co., Ltd. 
华为技术有限公司
All rights reserved
版权所有  侵权必究

（TST01T04 V2.0/ IPD-PTM V2.0 / for internal use only）
（TST01T04 V2.0/ IPD-PTM V2.0 / 仅供内部使用）
修订记录
日期	修订版本	描述	作者
2015-11-2	1.00	初稿完成	陈世锐 00354097
2015-11-2	1.01	评审修改	陈世锐 00354097





















目录
1   IQM简介
1.1	IQM的功能简介	2
1.2	IQM的处理流程	2
1.3	常用名词	4
2	IQM功能详解	5 
2.2	数据包重组	5
2.2.1	重组的原因	5
2.2.2	重组过程	6
2.2.3	异常报文处理	7
2.2.4	有序流通道映射	9
2.3	IQM与PBA/NP的通讯	12
2.3.1	Pull命令	13
2.3.2	Dispatch命令	14
2.3.3	NP复制	15
2.4	数据发送	16
2.5	资源的分配和回收	17
2.5.1	Cell Buff	18
2.5.2	PKT_ID	18
2.6	反压与丢弃	19
2.6.1	IQM与PA的反压与丢弃	20
2.6.2	IQM与PBA之间的反压	22
2.6.3	IQM被反压	23
2.6.4	反压和丢弃的应用	23


1	IQM简介
1.1	IQM的功能简介
IQM (Ingress Queue Manager，入口队列管理)，他的主要作用是入口流量的管理。当进入芯片的数据流量超过了NP的处理能力，这时候IQM通过反压或丢弃控制入口数据流量。
说到IQM，我们不得不提一下EQM(Egress Queue Manager，出口队列管理)。NP将处理完的数据发送给EQM，EQM负责调度发送数据。如果出口发生拥塞，无法将所有的数据包都发送出去。EQM会对高优先级的数据进行优先的处理和输出，从而保证重要业务的服务质量。而EQM在出口实现HQoS功能。

 
1.2	IQM的处理流程
我们完成了“从大处着眼”，了解了IQM的基本功能。接下来在从“小处着手”，了解一下IQM在芯片内部的“邻居们”，以及一个数据进来之后他们是如何相互协作的。如下图：
   
1.	我们IQM的“上级供应商”是“PA”，PA把货物的单据和货物分开发送过来。
2.	IQM根据单据给货物分配仓库存储，并把单据和货物通过PBA交给NP处理。
3.	NP把处理结果交给IQM，IQM根据NP指示把货物从仓库取出来，交给PE。

接下来，我们看一个更加详细一点的数据处理的流程图：

 
1.	PA将数据和控制信息分别发送给IQM。
2.	IQM对报文进行重组，并存放在PLB中。
3.	报文重组完成以后，IQM将报文通过PBA提交给NP处理。
4.	NP处理完之后，发送命令给IQM，指示IQM处理和发送数据。
5.	IQM根据命令，将相应的报文从PLB中取出，并提交给PE。
1.3	常用名词
接下来的讲解中会用到很多名词，为了大家方便后面的阅读，这里对用到的名词做简单的介绍。
Term	Description
PLB	Packet Latency Buffer，用来缓存NP正在处理和等待处理的报文。类似于仓库的功能。
PKT_ID	NP子系统在处理报文时的标识符。在整个NP处理过程中都会基于PKT_ID进行处理。类似于一个处理货物电子流程。
CID	报文的Cell缓存在PLB的指针。类似于在货物仓库中的存储位置信息。
HCID	报文首Cell缓存在PLB的指针。
PD	Packet Descriptor，报文的描述信息。货物的描述信息。
IFB	Internal Frame Buffer，EQM的片内报文缓存。
EFB	External Frame Buffer，EQM的片外报文缓存。
NPR	NP Replication，NP复制。对应组播业务的应用。
2	IQM功能详解
数据进入到了IQM，可以分为以下几个步骤处理：
1.	数据重组；
2.	向PBA进行入队注册；
3.	接收NP的发送指令并发送数据。
当然这中间也伴随了资源的管理、IQM的反压和反压响应等功能。
2.2	 数据包重组
简单的说，IQM收到的是切割后的零散的Cell，那么对于同一个Packet切割成的Cell，我们要把它重新组成一个Packet。数据重组实际上是IQM将报文提交NP之前做的准备工作。
2.2.1	重组的原因
IQM重组是因为PA传输过来的是Cell而不是完整的Packet。进入芯片的都是报文为什么到了IQM变成了Cell呢？ 
实际上报文进入芯片之后会被切割成Cell。这种做法是为了提高IQM缓存（PLB）利用率。PLB通常用的存储单元是SRAM，SRAM的特点是处理速度快，但是成本高、功耗大、占用面积大。所以有效的利用SRAM可以降低成本和芯片面积。Cell切割的太大，利用率不高；Cell切割的太小，管理开销太大。所以Cell一般100Byte左右，当然不同的芯片参数也有所不同。
 
那么NP为什么不直接处理Cell？
NP处理数据都是按照报文为粒度来进行处理的，比如编辑、转发、丢弃等，所以在IQM中需要对Cell进行重组。对于这一步还不了解，你可以想象“汽车出问题时，都是按照批次进行召回的，而不是针对单个的车进行召回”。这里的批次就类似于Packet，每一个汽车就像Cell。
2.2.2	重组过程
IQM收到的是交织的Cell，如何进行重组？
来自各个不同通道（channel）的数据通过PA后汇聚成了一个通路。PA的调度是基于Channel的，那么IQM的重组也是基于Channel的。重组的简单过程如下图：
	
 
	注： 虽然Packet被切成了很多Cell，但是Cell传输时，仍以一个报文为单位传输。
1	PA将Cell数据直接送到MEMP中的PLB，Cell的控制信息送到IQM。IQM收到控制信息后会向PLB申请缓存资源，用于存放Cell数据。（类似于管理人员收到了货物清单，仓库收到了货物，这时候管理人员会分配仓库给货物分配空间。）
2	 IQM在接收Cell并为其分配Cell指针的同时也创建以HCID（Head Cell ID）为首节点的链表以对Cell进行重组形成完整的报文。当一个报文的最后一个Cell收到后，就完成了一个报文的重组。（类似于仓库将同一批次的货物存储位置记录下来。）
3	如果重组后的报文没有发生任何错误，那么这个报文就可以送NP去进行处理了，即把报文信息（如HCID、IC、AGID和PRI等）送PBA的New Packet队列去入队。（货物接收没有异常，接着就可以给领导处理了。）
这里需要注意的是，我们上面所讲的重组的过程是基于正常的报文而言的。IQM收到的报文还有一部分是带有Abort标记（如PA检查到SOP或者EOP缺失时会将报文标记成Abort）。对于带Abort标记的报文，IQM会根据寄存器的配置来决定如何处理。如下：
 
2.2.3	异常报文处理
重组过程中会遇到一些异常状况，如：错误帧，超长帧。对于这种异常的情况，我们需要有一个合理处理机制来保证重组正常有序的进行。
1	帧错误处理
一个报文被切割之后的Cell一般可以分为三类：SOP（Start of Packet）、MOP（Middle of Packet）、EOP（End of Packet）。如果报文是单Cell（如64Byte短包），那么IQM接收到的只有一个SEOP（Start and End of Packet）Cell。
正常情况：
 
异常情况主要包括两种：缺少EOP、缺少SOP。
缺少EOP：
 	出现这种情况原因：丢失EOP、或者报文中MOP变成了SOP。
为了防止MOP变成了EOP这种情况，需要丢弃EOP以及之前的Cell。

缺少SOP：
 
当SOP变成MOP，或者SOP丢失，那么就会出现缺少SOP的情况。这时需要把下一个SOP之前的Cell全部丢弃。从下一个SOP开始进行重组。
2	超长帧处理
 	在报文重组过程中，如果报文的EOP没有及时到来，报文就会一直占用重组通道资源和Cell资源，而影响其他报文的重组。这就类似于超市排队买单一样，如果一个人买了太多的东西，就会导致结账时间过长，排队的其他人无法得到及时的服务。极端一点，这个人买了半个超市的货物，那么他所在的队列的就会堵死。对应于芯片业务的话，就是数据无法得到转发和处理。某些用户或者某些应用会受到影响。那么为了避免这种情况，IQM会检查每个正在重组的报文长度是否超过配置的最大报文长度。如果超过这个长度，这个报文会被作为超长帧错误而被丢弃。在报文丢弃后和新的SOP前这段间隔内收到的Cell也都直接丢弃。当再收到1个新的SOP时，重组流程重新开始。
2.2.4	有序流通道映射
报文重组完成之后，数据和链表信息存放在PLB中。而每个数据的控制信息存放在有序流通道中。我们知道报文进入芯片之后在不同的IC（Input Channel，输入通道）中传输，IQM中也有与其一一对应的重组通道来重组这些数据包。
 
那么IQM又是如何将重组通道映射到有序流通道的呢？
有序流通道的映射方式有两种：
1.	如果芯片的IC较少，那么有序流通道可以与重组通道一一对应
2.	如果芯片的IC很多，那么就需要对重组通道压缩对应有序流通道。
IC的多少是因芯片不同而变化，与芯片的实现有关系。有序流通道数量相对较少。第一种方式比较简单，这里我们就不在赘述。对于第二种压缩对应，我们做一个详细的介绍。
对重组通道进行压缩的方式有分为两种，优先级模式和非优先级模式。
非优先级模式：
 
优先级模式：

 
优先级模式：首先按照重组通道号（557个）映射成压缩通道（64个），在按照通道内数据的优先级信息，将压缩通道扩展成有序流（128个）。这里括号里的参数是以某个芯片为例，出现参数是为了方便理解通道数量的变化，这些参数随芯片不同而变化。
非优先级模式：重组通道（557个）直接映射到有序流通道（128个）。
芯片最先采用的是非优先级模式，其优势是实现简单，但是无法保证不同优先级的数据进行区分处理。为了保证高优先级的报文能够低延时处理，我们设计了优先级模式。优先级模式和非优先级模式的映射都有一个固定的映射关系。这个映射关系式人为设定的。这里不再介绍。两种模式可以自由选择，这里的优先级模式中的优先级是从PA映射过来的。PA会分析报文，得出4种优先级信息，并将这些信息传给IQM。IQM会根据PA的四个优先级映射成两个优先级，并提交给NP处理。
2.3	 IQM与PBA/NP的通讯
IQM完成数据包的重组和通道的映射之后，会将通道中的Packet信息向PBA注册。IQM入队的信息包括HCID（数据在哪儿）、Input Channel（从哪儿来的数据）、AGID（交给哪个NP组处理）和PRI（优先级信息）等。
我们对这个过程做一个简单介绍。
 1. IQM处理完货物（报文重组）之后，会把报文信息在PBA中进行入队注册。
2. 当PBA检测到有进程空闲的时候，就会发送一个Pull New请求。
3. IQM接收到Pull New请求之后，便会读取相应的首Cell，为他分配PCK_ID，并送给PBA。
4 .PBA将接收到的数据以及控制信息传输给NP。
5. NP处理数据，并根据需求给IQM发送不同的Pull指令。处理完成后NP发送dispatch命令，指示IQM处理数据。
这个过程中，IQM接收到的命令有两种。一种“Pull”请求，用来读取Cell内容的；一种是dispatch命令，NP用来下发处理结果的。接下来我们介绍一下各个命令的作用。
Command	Description
PullNew	请求IQM为HCID指定的报文分配一个PKT_ID，并且返回这个报文的第一个Cell。这个命令是每个报文的第一个Pull请求，该命令来源于PBA。
PullPkt	请求IQM分配一个PKT_ID，这个PKT_ID没有实体的报文与其对应。这个命令来源于在NP中执行的PullReset指令加上一个特殊的操作符。
PullReset	请求IQM为PKT_ID指定的报文返回第一个Cell。这个命令来源于在NP中执行的PullReset指令。
PullSame	请求IQM将PKT_ID指定的报文的上一次返回的Cell再重新返回一次。当执行一个AWPP指令时，ATOM可能会自动产生这个请求。
PullNext	请求IQM将PKT_ID指定的报文的下一个Cell返回。当响应一个AWPP指令时，ATOM可能会自动产生这个请求。
TransmitAndNotFree	发送PKT_ID指定的报文到PE模块。IQM在响应这种Transmit请求时，无条件释放PKT_ID，但不释放CID。IQM将HCID以及其它控制信息重新向PBA注册。该命令针对于组播的NP复制。
TransmitAndFree	发送PKT_ID指定的报文到PE模块。IQM在响应这种Transmit请求时，无条件的释放PKT_ID和CID。
2.3.1	Pull命令
NP在处理报文时，还可能需要获取各种各样的信息才能处理报文。这时候NP通过向IQM发送Pull命令，来获取控制信息或者Cell数据。
IQM作为下属，收到老大NP的Pull命令之后需要积极配合并提供所需的信息和数据。根据老大指示的货物存放地址（HCID）或者电子流（PKT_ID）信息，IQM去仓库（PLB）中获取相应的货物参数（Cell Data），并把货物（Cell）连同货物信息（如Packet Length、LBO（Last Byte Offset in the Cell）、Packet Type、 Input Channel、Tag_Num等）返回给NP。 
对Pull请求的响应不会引起Cell的释放（货物没有被搬出，仍在仓库中占用仓库资源）。IQM支持NP对一个报文的所有Cell的读取（查看所有货物信息），并且读取的次数不受限制（查看货物不限次数）。只有当报文被Dispatch（即老大NP让搬货出去）后Cell才会释放（占用的仓库资源才会释放）。
2.3.2	Dispatch命令
NP在完成报文处理后就会向IQM下达处理指令。这个指令就是Dispatch命令，IQM收到Dispatch命令，并放入对应的队列然后等待调度。IQM根据指令发送报文给PE进行进一步的处理或丢弃。我们先看一下IQM的队列分类：
 
IQM队列接收数据示意图：
 
1. 从PA过来Cell在IQM中首先通过CID链进行重组，重组失败的CID链入队Reasembly失败丢弃队列，等待丢弃，丢弃后释放相应的Cell资源；							
2. 重组成功的报文，在NP有空闲线程时，IQM为报文分配PKT_ID，并提交给NP处理。NP处理完成后下发Discard命令给IQM。IQM根据NP指示将命令放入不同队列，Dispatch队列是PKT_ID链。
3. 对不同的队列进行SP+DWRR调度，根据调度出的指令，来处理相应的报文。
这里需要注意都是Dispatch命令有两种，这两种命令在IQM中执行的时候有所不同。

 

 TransmitAndFree发送PKT_ID指定的报文到PE模块。IQM在响应这种Dispatch请求时，无条件的释放PKT_ID和CID。IQM在响应这种Dispatch请求时，无条件释放PKT_ID，但不释放CID。IQM将HCID以及其它控制信息重新向PBA注册。
2.3.3	NP复制
NP复制是用于组播复制的一种方式，顾名思义，完成复制的位置是在NP中。上面我们讲了有专门用于组播复制的TransmitAndNotFree命令，那么NP复制是如何完成的呢？
 
这里面有两个资源，一个是用来存储报文数据的PLB（仓库），一个用来对报文进行入队注册的PKT_ID（发货流程）。对于普通报文，在收到NP的发送指令后，取出报文并释放PKT_ID（发货流程结束）和PLB的Cell资源（货物搬出）。对于组播报文，只释放PKT_ID（流程结束），不释放PLB中的Cell（货物复制一份送出，原来的货物仍在仓库中），在报文发送之后重新进行PBA入队注册（重提一个发货流程）。如此反复，直到复制完最后一个组播报文之后，才释放PLB中的Cell资源。
2.4	数据发送
IQM收到NP发送过来的Dispatch命令之后，会将命令存入相应的队列。IQM数据发送的过程实际上就是IQM在队列之间对Dispatch命令调度的过程。
IQM的输出调度是层次化的调度。第一级调度是在两个队列组和两个丢弃队列之间采用SP+DWRR调度。第二级调度是在队列组内部调度，也支持SP+DWRR调度。这些调度的权重均可以配置。当然也可以设置成只支持其中一种的调度方式。队列组内以及队列组之间还支持shaper（流量整形）功能，但是默认是关闭的。这是因为shaper主要在出口（EQM）处，目的是平稳均匀的输出数据流。而IQM只是粗粒度的进行管理。

 

IQM在输出队列中调度，并将调度出的报文数据发送给PE，则还要执行以下的操作：
	IQM将PKT_ID回收。
	如果报文的Dispatch请求携带的Free_PKT有效，IQM将Cell指针即CID回收。
	如果报文的Dispatch请求携带的Free_PKT无效，则不释放CID，IQM将报文信息向PBA入队注册。
2.5	资源的分配和回收
IQM使用的资源分为两种：数据存储资源Cell Buff和数据处理流程资源PKT_ID。接下来，我们做一个简单介绍。
2.5.1	Cell Buff
这个实际上就是PLB，是用来存储Cell数据的地方。为了提高处理速度，PLB多用SRAM来做，一般有多片Slice组成。为充分利用每一片的带宽，IQM在分配资源的时候会在Slice之间进行RR调度。Cell数据被均匀的分配到每一片中。分配资源主要是发生在在重组报文过程中。每收到一个Cell数据，IQM就会向PLB请求Cell资源进行存储。
但是在以下几种情况不会分配资源给Cell。
1. 重组状态出错即发生SOP和EOP不匹配错误； 
2. 从PA收到的EOP的Cell携带Abort标记，且寄存器配置为丢弃； 
3. Cell资源检查没有通过，主要是资源不足引起的； 
资源释放主要发生在报文转发之后。单播报文或NPR复制的最后一份叶子发送之后， Cell资源可回收。此外，Reassembly Discard队列的报文在出队后也可以回收CID。
2.5.2	PKT_ID
上送NP处理的报文都有一个Packet Identifier称之为PKT_ID， PKT_ID的分配和回收由IQM来管理，PKT_ID的数目是有限的。 这个PKT_ID就类似于停车卡的功能。

 

当IQM从PBA接收到PullNew或PullPac请求时，就会分配一个PKT_ID。
当PullNew或PullPac命令接收太快达到了IQM的反压水线时，IQM就会向PBA反压，这时候PBA不再发送Pull命令。 
当报文被发送到PE后， IQM无条件回收当前的PKT_ID。
2.6	反压与丢弃
 	当你工作快处理不过来的时候，通知你的上一级减少送过来的工作，这就是反压。反压是为了避免拥塞。在芯片中反压常出现在资源不够或者处理速度不够的情况中。对于IQM来讲，他既可以向前端反压，又可以接受后一级的反压。当然你除了通知上级不要送新的工作以外，你还可以选择丢弃。
接下来，我们看看IQM中都有哪些地方存在着反压。
 
当PLB中的缓存资源不足（仓库快存满了）的时候，IQM会向PA反压（通知前一级先不要送货过来）。
当IQM中的PKT_ID不足（PBA请求太快，PKT_ID不足）的时候，IQM会向PBA反压，PBA停止发送Pull请求。
当然IQM还会响应PLB和PE的反压，他们之间的反压是模块之间都有的FIFO反压。 
2.6.1	IQM与PA的反压与丢弃
反压
IQM与PA之间的反压实际上是对Cell资源的管理。IQM对PA的反压是层次化的，包括Channel级反压、Port级反压、Port Group级反压。他们之间的关系如下图：
 

1. 每个Channel都有一个反压水线（这个就像是水位的警戒线），当这个channel中的数据达到了反压水线之后，就会产生channel级的反压；
2.每个Port也有一个反压水线，当该Port下的多个channel出现拥塞达到Port的反压水线，Port级反压被置起，那么该端口下的所有Channel级反压都将置起，无论当前IC用的CB是否超过了其反压置起水线。
3. 每个Port Group也有一个反压水线，当该Port Group下的多个Port出现拥塞达到Port Group的反压水线，Port Group级反压被置起，那么该端口下的所有Port级反压都将置起，无论Port用的CB是否超过了其反压置起水线。
所有级别的反压都是直接透传到接口的MAG模块、EPS模块或PIE模块。
反压的置起与撤销
各层次反压置起受影响的因素：
	所属Channel反压	所属Port反压	所属Port Group反压
Channel级反压						
Port级反压					
Port Group级反压				
只要有一个受影响因素反压置起就会该级别的反压也会置起。

各层次反压撤销条件：
Channel级：所属Channel、所属Port、所属Port Group均达到反压撤销水线。
Port级：所属Port、所属Port Group均达到反压撤销水线。
Port Group级：所属Port Group达到反压撤销水线。
他们之间的关系我们可以想象小区的用水管道
反压置起：对于住户来说，楼栋水管、楼层水管、住户水管有一个关闭，那么住户家里就没有水。
反压撤销：所有的开关都打开，用户家里才会有水。


  

丢弃
IQM除了支持Channel级丢弃、Port级丢弃、Port Group级丢弃，还支持基于优先级（这是优先级是PA分析后传输过来的）的GLB丢弃，对于每个丢弃优先级。Channel级丢弃、Port级丢弃、Port Group级丢弃的处理机制同反压机制相同。对于GLB丢弃，当GLB CB被占用的计数超过某个优先级的GLB丢弃水线时，则对应这个优先级的GLB丢弃置起。这里GLB没有反压，这是因为当全局都出现反压的时候，整个线路已经非常拥塞，业务都会严重受到影响。所以直接采用丢弃。
2.6.2	IQM与PBA之间的反压
IQM对PBA的反压实际上是对PKT_ID的资源管理。基于IC、IP和IPG的PKT_ID资源管理是平衡各个IC或IP以及IPG对PKT_ID资源的占用；GLB的PKT_ID的资源管理是在PBA和IQM之间产生基于PKT_ID使用数量的流控，进而保证PKT_ID从来都不会被耗尽。
IQM与PBA之间的反压与IQM与PA之间的反压机制是相同的。不同的就是IQM与PBA之间反压多了一个Global级的反压。当Global级反压置起的时候，所有的channel级反压都会被置起。IQM与PBA之间只有反压，没有丢弃。这是因为当PBA收到反压之后，就会停止发送PullNew命令。
2.6.3	IQM被反压
IQM被反压主要是被PE和PLB反压。IQM同这两个模块之间的反压都是基于FIFO的反压。这种反压存在于芯片内部任意两个模块之间。当IQM向PE或者PBA发送的数据过快，而导致数据在FIFO中积累。当达到反压水线的时候，FIFO就会反压置起。
 

当然IQM除了响应PBA和PE的直接反压以外，IQM还能够响应来自EQM的反压。EQM调度出现拥塞的时候会向前反压，并通过PE透传（此反压与PE无关，此处PE相当于透明的）到IQM，IQM接受反压停止发包，直到反压撤销。
 反压和丢弃的应用
当处理能力不足或者存储空间不足的时候，就需要采取一定的措施，以防出现“决堤”的情况。主要有两种，反压和丢弃。反压：通知前端，暂停发送。丢弃：不声不响，直接丢掉。这两种方式是相辅相成的，不同的场景可以使用不同的方式，对于报文来讲。
1.	   反压多作用于芯片之间，比如像IQM会有一个反压水线和一个丢弃水线。当达到反压水线的时候会产生反压。当对端不响应反压或者响应较慢达到丢弃水线，就会发生丢包。
2.	   丢弃多用于芯片内部。当数据进入芯片之后，芯片会尽最大的能力去处理，当处理不过来就直接丢弃。但是也有例外，如IQM和PBA之间只有反压。

